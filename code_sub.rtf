{\rtf1\ansi\ansicpg1252\cocoartf2638
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red191\green100\blue38;\red32\green32\blue32;\red153\green168\blue186;
\red254\green187\blue91;\red86\green132\blue173;\red117\green114\blue185;\red109\green109\blue109;\red88\green118\blue71;
\red152\green54\blue29;\red95\green96\blue103;}
{\*\expandedcolortbl;;\csgenericrgb\c74902\c39216\c14902;\csgenericrgb\c12549\c12549\c12549;\csgenericrgb\c60000\c65882\c72941;
\csgenericrgb\c99608\c73333\c35686;\csgenericrgb\c33725\c51765\c67843;\csgenericrgb\c45882\c44706\c72549;\csgenericrgb\c42745\c42745\c42745;\csgenericrgb\c34510\c46275\c27843;
\csgenericrgb\c59608\c21176\c11373;\csgenericrgb\c37255\c37647\c40392;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs22 \cf2 \cb3 import \cf4 numpy \cf2 as \cf4 np\
\cf2 import \cf4 pandas \cf2 as \cf4 pd\
\cf2 import \cf4 matplotlib.pyplot \cf2 as \cf4 plt\
\cf2 from \cf4 nelson_siegel_svensson.calibrate \cf2 import \cf4 calibrate_ns_ols\cf2 , \cf4 calibrate_nss_ols\
\cf2 from \cf4 datetime \cf2 import \cf4 datetime\
\cf2 from \cf4 scipy.optimize \cf2 import \cf4 minimize\cf2 , \cf4 fmin\
\
\
\
\
\cf2 def \cf5 GeneratePathsHestonEuler\cf4 (NoOfPaths\cf2 , \cf4 NoOfSteps\cf2 , \cf4 T\cf2 , \cf4 r\cf2 , \cf4 S_0\cf2 , \cf4 kappa\cf2 , \cf4 gamma\cf2 , \cf4 rho\cf2 , \cf4 vbar\cf2 , \cf4 v0\cf2 , \cf4 strike):\
\
    Z1 = np.random.normal(\cf6 0.0\cf2 , \cf6 1.0\cf2 , \cf4 [NoOfPaths\cf2 , \cf4 NoOfSteps])\
    Z2 = np.random.normal(\cf6 0.0\cf2 , \cf6 1.0\cf2 , \cf4 [NoOfPaths\cf2 , \cf4 NoOfSteps])\
    W1 = np.zeros([NoOfPaths\cf2 , \cf4 NoOfSteps + \cf6 1\cf4 ])\
    W2 = np.zeros([NoOfPaths\cf2 , \cf4 NoOfSteps + \cf6 1\cf4 ])\
    V = np.zeros([NoOfPaths\cf2 , \cf4 NoOfSteps + \cf6 1\cf4 ])\
    X = np.zeros([NoOfPaths\cf2 , \cf4 NoOfSteps + \cf6 1\cf4 ])\
    V[:\cf2 , \cf6 0\cf4 ] = v0\
    X[:\cf2 , \cf6 0\cf4 ] = np.log(S_0)\
\
    time = np.zeros([NoOfSteps + \cf6 1\cf4 ])\
\
    dt = T / \cf7 float\cf4 (NoOfSteps)\
    \cf2 for \cf4 i \cf2 in \cf7 range\cf4 (\cf6 0\cf2 , \cf4 NoOfSteps):\
        \cf8 # making sure that samples from normal have mean 0 and variance 1\
        \cf2 if \cf4 NoOfPaths > \cf6 1\cf4 :\
            Z1[:\cf2 , \cf4 i] = (Z1[:\cf2 , \cf4 i] - np.mean(Z1[:\cf2 , \cf4 i])) / np.std(Z1[:\cf2 , \cf4 i])\
            Z2[:\cf2 , \cf4 i] = (Z2[:\cf2 , \cf4 i] - np.mean(Z2[:\cf2 , \cf4 i])) / np.std(Z2[:\cf2 , \cf4 i])\
        Z2[:\cf2 , \cf4 i] = rho * Z1[:\cf2 , \cf4 i] + np.sqrt(\cf6 1.0 \cf4 - rho ** \cf6 2\cf4 ) * Z2[:\cf2 , \cf4 i]\
\
        W1[:\cf2 , \cf4 i + \cf6 1\cf4 ] = W1[:\cf2 , \cf4 i] + np.power(dt\cf2 , \cf6 0.5\cf4 ) * Z1[:\cf2 , \cf4 i]\
        W2[:\cf2 , \cf4 i + \cf6 1\cf4 ] = W2[:\cf2 , \cf4 i] + np.power(dt\cf2 , \cf6 0.5\cf4 ) * Z2[:\cf2 , \cf4 i]\
\
        \cf8 # Truncated boundary condition\
        \cf4 V[:\cf2 , \cf4 i + \cf6 1\cf4 ] = V[:\cf2 , \cf4 i] + kappa * (vbar - V[:\cf2 , \cf4 i]) * dt + gamma * np.sqrt(V[:\cf2 , \cf4 i]) * (W1[:\cf2 , \cf4 i + \cf6 1\cf4 ] - W1[:\cf2 , \cf4 i])\
        V[:\cf2 , \cf4 i + \cf6 1\cf4 ] = np.maximum(V[:\cf2 , \cf4 i + \cf6 1\cf4 ]\cf2 , \cf6 0.0\cf4 )\
\
        X[:\cf2 , \cf4 i + \cf6 1\cf4 ] = X[:\cf2 , \cf4 i] + (r - \cf6 0.5 \cf4 * V[:\cf2 , \cf4 i]) * dt + np.sqrt(V[:\cf2 , \cf4 i]) * (W2[:\cf2 , \cf4 i + \cf6 1\cf4 ] - W2[:\cf2 , \cf4 i])\
        time[i + \cf6 1\cf4 ] = time[i] + dt\
\
    \cf8 # Compute exponent\
    \cf4 S = np.exp(X)\
    price = np.exp(r * T) * np.mean(np.maximum(strike - S[:\cf2 , \cf4 -\cf6 1\cf4 ]\cf2 , \cf6 0\cf4 ))\
    \cf2 return \cf4 price\
\
\cf2 def \cf5 evaluate\cf4 (x):\
    kappa\cf2 , \cf4 gamma\cf2 , \cf4 rho\cf2 , \cf4 vbar\cf2 , \cf4 v0 = x\
    market_data = pd.read_csv(\
        \cf9 '/Users/pierreranchet/Documents/Sauvegarde_PC/Dauphine/Cours/S2/Produits_Structures/Projet_Autocall/FTSE_Prices.csv'\cf2 ,\
        \cf10 sep\cf4 =\cf9 ";"\cf4 )\
    market_data.Maturity = np.array(\
        [(datetime.strptime(i\cf2 , \cf9 '%m/%d/%Y'\cf4 ) - datetime.today()).days \cf2 for \cf4 i \cf2 in \cf4 market_data.Maturity]) / \cf6 365\
    \cf4 df_rates = pd.read_csv(\
        \cf9 '/Users/pierreranchet/Documents/Sauvegarde_PC/Dauphine/Cours/S2/Produits_Structures/Projet_Autocall/UK OIS spot curve.csv'\cf2 ,\
        \cf10 sep\cf4 =\cf9 ";"\cf4 )\
    yield_maturities = df_rates[\cf9 'Maturities'\cf4 ].to_numpy(\cf9 'float'\cf4 )\
    yields = df_rates[\cf9 'Rates'\cf4 ].to_numpy(\cf9 'float'\cf4 ) / \cf6 100\
    \cf4 curve_fit\cf2 , \cf4 status = calibrate_ns_ols(yield_maturities\cf2 , \cf4 yields\cf2 , \cf10 tau0\cf4 =\cf6 1.0\cf4 )\
    market_data[\cf9 'Rates'\cf4 ] = curve_fit(market_data[\cf9 'Maturity'\cf4 ])\
\
\
    error = \cf6 0.0\
    \cf2 for \cf4 data \cf2 in \cf4 market_data.values:\
\
        k\cf2 , \cf4 price\cf2 , \cf4 mat\cf2 , \cf4 r = data\
        price_heston = GeneratePathsHestonEuler(\cf10 NoOfPaths \cf4 = \cf6 1000\cf2 , \cf10 NoOfSteps \cf4 = \cf6 1000\cf2 , \cf10 T \cf4 = mat\cf2 , \cf10 r \cf4 = r\cf2 , \cf10 S_0 \cf4 = \cf6 7323.41\cf2 , \cf10 kappa \cf4 = kappa\cf2 , \cf10 gamma \cf4 = gamma\cf2 , \cf10 rho \cf4 = rho\cf2 , \cf10 vbar \cf4 = vbar\cf2 , \cf10 v0 \cf4 = v0\cf2 , \cf10 strike \cf4 = k)\
        error = (price_heston - price)**\cf6 2\
\
    \cf2 return \cf4 error\
\
\
\cf2 def \cf5 calibrate\cf4 ():\
    \cf8 #x = np.array([3.0, 0.25, -0.7, 0.15, 0.1])\
    #error = evaluate(x)\
\
    \cf4 params = \{\cf9 "kappa"\cf4 : \{\cf9 "x0"\cf4 : \cf6 3.0\cf2 , \cf9 "bd"\cf4 : [\cf6 1e-3\cf2 , \cf6 10\cf4 ]\}\cf2 ,\
              \cf9 "gamma"\cf4 : \{\cf9 "x0"\cf4 : \cf6 0.25\cf2 , \cf9 "bd"\cf4 : [\cf6 1e-2\cf2 , \cf6 2\cf4 ]\}\cf2 ,\
              \cf9 "rho"\cf4 : \{\cf9 "x0"\cf4 : -\cf6 0.7\cf2 , \cf9 "bd"\cf4 : [-\cf6 1\cf2 , \cf6 1\cf4 ]\}\cf2 ,\
              \cf9 "vbar"\cf4 : \{\cf9 "x0"\cf4 : \cf6 0.15\cf2 , \cf9 "bd"\cf4 : [\cf6 1e-3\cf2 , \cf6 0.8\cf4 ]\}\cf2 ,\
              \cf9 "v0"\cf4 : \{\cf9 "x0"\cf4 : \cf6 0.1\cf2 , \cf9 "bd"\cf4 : [\cf6 1e-3\cf2 , \cf6 1\cf4 ]\}\
              \}\
\
    x0 = np.array([param[\cf9 "x0"\cf4 ] \cf2 for \cf4 key\cf2 , \cf4 param \cf2 in \cf4 params.items()])\
    \cf11 result \cf4 = minimize(evaluate\cf2 , \cf4 x0\cf2 , \cf10 tol\cf4 =\cf6 1e-3\cf2 , \cf10 method\cf4 =\cf9 'Nelder-Mead'\cf2 , \cf10 options\cf4 =\{\cf9 'maxiter'\cf4 : \cf6 1e4\cf4 \})\
    \cf11 result2 \cf4 = fmin(evaluate\cf2 , \cf4 x0\cf2 , \cf10 maxiter \cf4 = \cf6 50\cf4 )\
\
    \cf7 print\cf4 (\cf9 'HH'\cf4 )\
\
\
\
\
calibrate()\
\
\
S = GeneratePathsHestonEuler(\cf10 NoOfPaths \cf4 = \cf6 1000\cf2 , \cf10 NoOfSteps \cf4 = \cf6 1000\cf2 , \cf10 T \cf4 = \cf6 6\cf2 , \cf10 r \cf4 = \cf6 0.02\cf2 , \cf10 S_0 \cf4 = \cf6 7323.41\cf2 , \cf10 kappa \cf4 = \cf6 3.0\cf2 , \cf10 gamma \cf4 = \cf6 0.25\cf2 , \cf10 rho \cf4 = -\cf6 0.7\cf2 , \cf10 vbar \cf4 = \cf6 0.12\cf2 , \cf10 v0 \cf4 = \cf6 0.1\cf4 )[\cf9 'S'\cf4 ]\
price = np.exp(\cf6 0.02\cf4 *\cf6 6\cf4 ) * np.mean(np.maximum(\cf6 7323.41 \cf4 - S[:\cf2 ,\cf4 -\cf6 1\cf4 ]\cf2 , \cf6 0\cf4 ))\
\
\cf7 print\cf4 (\cf9 'Hello'\cf4 )\
\
\
\
}